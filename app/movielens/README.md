# Calculate Movie Rating Average

In this example, calculate movie rating average from "*MovieLens 20M dataset*"[\[1\]](#ref1).
([link(kaggle)](https://www.kaggle.com/grouplens/movielens-20m-dataset))
In this app, the objective is calculating rating mean for each movie,
therefore, `rating.csv` is used.

The implementation is in `./main.cc`.
Before executing the script, ran preprocessing to split data into multiple files by year.
This dataset has the data from *1995* to *2015* in year, therefore, in total 21 files.
(Without split, it could not get performance gain,
rather got much slower due to huge overhead to split data and pass through network and it cannot parallelize for the map process.
The results for 1 PC and 2 PCs were 33.6sec and 34.2sec respectively.)

In this time, to compute baseline, `python pandas` library running on `Jupyter Notebook` is used,
instead of writing own script by `c++`.
Also, note that the baseline does not use split files,
but directly read `rating.csv` and compute the mean.

The script is roughly following,
```python
# python==3.8.5
# pandas==1.2.0

df = pd.read_csv("/path/to/rating.csv")
means = df[['movieId', 'rating']].groupby('movieId').mean()

# to validate the result
# read from outputs generated by SimpleMapReduce
smr = pd.read_csv("/path/to/output", delimiter='\t')
smr.columns = ['movieId', 'rating2']

# merge two results by movie IDs and compare the differences
res = pd.merge(means, smr)
(res['rating'] - res['rating2']).mean()
```

The performance result is:

| Baseline | SimpleMapReduce</br>(1 machine, 1 master, 3 workers) | SimpleMapReduce</br>(2 machines, 1 master, 7 workers) |
|--|--|--|
|14.230 sec. | 14.198 sec. | 9.044 sec. |

Note that the baseline (pandas ver.) includes time for loading data and writing the result to a csv file to be fair.

## Reference
<a name="ref1"></a>\[1\] F. Maxwell Harper and Joseph A. Konstan. 2015. The MovieLens Datasets: History and Context. ACM Transactions on Interactive Intelligent Systems (TiiS) 5, 4, Article 19 (December 2015), 19 pages.